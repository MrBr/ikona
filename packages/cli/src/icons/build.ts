// import crypto from 'crypto';
// import dedent from 'dedent';
// import fsExtra from 'fs-extra';
// import { glob } from 'glob';
// import { parse } from 'node-html-parser';
// import * as path from 'node:path';

// import { getCommandLineArg } from '../utils/args';
// import { validatePath, writeIfChanged } from '../utils/validations';

// const cwd = process.cwd();

// const inputDir = getCommandLineArg('input-dir');
// validatePath(inputDir, 'Input dir is required');

// const inputDirRelative = path.relative(cwd, inputDir);
// const typeDir = path.join(cwd, 'types');

// const outputDir = getCommandLineArg('output-dir');
// validatePath(outputDir, 'Output dir is required');

// const componentsOutputDir = getCommandLineArg('components-output-dir');
// validatePath(componentsOutputDir, 'Preload component output dir is required');

// const elementsOutputDir = path.join(componentsOutputDir, 'elements');

// await fsExtra.ensureDir(outputDir);
// await fsExtra.ensureDir(typeDir);
// await fsExtra.ensureDir(componentsOutputDir);
// await fsExtra.ensureDir(elementsOutputDir);

// const command = 'yarn workspace web run gen:icons:build';
// const generatedByText = `This file is generated by ${command}. Don't edit it manually.`;

// const files = glob
// 	.sync('**/*.svg', {
// 		cwd: inputDir,
// 	})
// 	.sort((a, b) => a.localeCompare(b));

// const shouldVerboseLog = process.argv.includes('--verbose') || process.argv.includes('-v');
// const logVerbose = shouldVerboseLog ? console.log : () => {};

// if (files.length === 0) {
// 	console.log(`No SVG files found in ${inputDirRelative}`);
// } else {
// 	await generateIconFiles(outputDir, inputDir, componentsOutputDir);
// }

// async function generateIconFiles(outputDir: string, inputDir: string, componentsOutputDir: string) {
// 	const spriteFilepath = path.join(outputDir, 'sprite.svg');
// 	const typeOutputFilepath = path.join(typeDir, 'icon-name.d.ts');
// 	const currentSprite = await fsExtra.readFile(spriteFilepath, 'utf8').catch(() => '');
// 	const currentTypes = await fsExtra.readFile(typeOutputFilepath, 'utf8').catch(() => '');

// 	const iconNames = files.map((file) => iconName(file));

// 	const spriteUpToDate = iconNames.every((name) => currentSprite.includes(`id=${name}`));
// 	const typesUpToDate = iconNames.every((name) => currentTypes.includes(`"${name}"`));

// 	if (spriteUpToDate && typesUpToDate) {
// 		logVerbose(`Icons are up to date`);
// 		return;
// 	}

// 	logVerbose(`Generating sprite for ${inputDirRelative}`);

// 	const output = await generateSvgSprite({
// 		files,
// 		inputDir,
// 	});

// 	const hash = crypto.createHash('md5').update(output).digest('hex');

// 	console.log(`Generated sprite with hash ${hash}`);

// 	const spriteChanged = await writeIfChanged(spriteFilepath, output, hash);

// 	for (const file of files) {
// 		logVerbose('âœ…', file);
// 	}
// 	logVerbose(`Saved to ${path.relative(cwd, spriteFilepath)}`);

// 	const stringifiedIconNames = iconNames.map((name) => JSON.stringify(name));

// 	const typeOutputContent = `// ${generatedByText}

// export type IconName =
// \t| ${stringifiedIconNames.join('\n\t| ').replace(/"/g, "'")};
// `;

// 	const typesChanged = await writeIfChanged(typeOutputFilepath, typeOutputContent);

// 	logVerbose(`Manifest saved to ${path.relative(cwd, typeOutputFilepath)}`);

// 	const readmeChanged = await writeIfChanged(
// 		path.join(inputDir, 'README.md'),
// 		dedent`# Icons

// 				This directory contains SVG icons that are used by the app.

// 				Everything in this directory is made into a sprite using \`${command}\` script. This file will show in /public/icons/sprite.svg\n`
// 	);

// 	const svgUseComponent = await writeIfChanged(
// 		path.join(elementsOutputDir, 'Use.tsx'),
// 		dedent`// ${generatedByText}
// 			export interface UseProps {
// 				name: string;
// 			}

// 			export const Use = ({ name }: UseProps) => (
// 				<use href={\`/icons/sprite.${hash}.svg#\${name}\`} />
// 			);\n
// 		`
// 	);

// 	const spritePreloadComponent = await writeIfChanged(
// 		path.join(componentsOutputDir, 'SpritePreload.tsx'),
// 		dedent`// ${generatedByText}
// 			import React from 'react';

// 			export const SpritePreload = () => (
// 				<link rel="preload" as="image/svg+xml" href="icons/sprite.${hash}.svg" />
// 			);\n
// 		`
// 	);

// 	if (spriteChanged || typesChanged || readmeChanged || svgUseComponent || spritePreloadComponent) {
// 		console.log(`Generated ${files.length} icons`);
// 	}
// }

// function iconName(file: string) {
// 	return file.replace(/\.svg$/, '').replace(/\\/g, '/');
// }

// /**
//  * Creates a single SVG file that contains all the icons
//  */
// async function generateSvgSprite({ files, inputDir }: { files: Array<string>; inputDir: string }) {
// 	// Each SVG becomes a symbol and we wrap them all in a single SVG
// 	const symbols = await Promise.all(
// 		files.map(async (file) => {
// 			const input = await fsExtra.readFile(path.join(inputDir, file), 'utf8');
// 			const root = parse(input);

// 			const svg = root.querySelector('svg');
// 			if (!svg) throw new Error('No SVG element found');

// 			svg.tagName = 'symbol';
// 			svg.setAttribute('id', iconName(file));
// 			svg.removeAttribute('xmlns');
// 			svg.removeAttribute('xmlns:xlink');
// 			svg.removeAttribute('version');
// 			svg.removeAttribute('width');
// 			svg.removeAttribute('height');

// 			return svg.toString().trim();
// 		})
// 	);

// 	return [
// 		`<?xml version="1.0" encoding="UTF-8"?>`,
// 		`<!-- ${generatedByText} -->`,
// 		`<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="0" height="0">`,
// 		`<defs>`, // for semantics: https://developer.mozilla.org/en-US/docs/Web/SVG/Element/defs
// 		...symbols,
// 		`</defs>`,
// 		`</svg>`,
// 		'', // trailing newline
// 	].join('\n');
// }
